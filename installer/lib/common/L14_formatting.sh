#the wrappers arround mkfs.*

formatting_wrapper_reiserfs(){
mkfs.reiserfs -f $1
}

formatting_wrapper_ext2(){
mkfs.ext2 $1
}

formatting_wrapper_ext3(){
mkfs.ext3 $1
}

formatting_wrapper_ext4(){
mkfs.ext4 $1
}

formatting_wrapper_xfs(){
mkfs.xfs -f $1
}

formatting_wrapper_swap(){
mkswap $1
}

formating_get_fs_list(){
    #this function just give the list of the fs used on the target system
    #$1 the partition section file
    local input_file=$1

    local CLEANED_PARTIONS_FILE=`mktemp`
    common_cleanup_file $input_file  $CLEANED_PARTIONS_FILE


    local tmp=`mktemp`
    while read -r line
    do
       local fs=`echo $line |cut -d ' ' -f 3` 
       if ! grep -q "^$fs$" $tmp
       then
           echo $fs >>$tmp
       fi
    done < $CLEANED_PARTIONS_FILE
    FS_LIST=`cat $tmp`
    rm $tmp
}

formatting_load_modules(){
    #this function loads the fs kernel modules needed for the install
    #$1 the partition section file
    local input_file=$1

    formating_get_fs_list $input_file

    for fs in $FS_LIST
    do
        if ! [ "$fs" = "swap" ]
        then
            modprobe $fs
        fi
    done

    #we need to wait after loading the fs modules
    #don't ask me why
    sleep 10
}

formatting_format_and_mount(){
    #this function formats the partitions, and mount the newly formatted partitions
    #it also generates the fstab for the futur system
    #$1 -> the partionning section file

    local input_file=$1

    #we clean the file (no comments or empty lines)
    local CLEANED_PARTIONS_FILE=`mktemp`
    common_cleanup_file $input_file $CLEANED_PARTIONS_FILE

    #we load the needed modules
    partitionning_get_disks_list $CLEANED_PARTIONS_FILE
    formatting_load_modules $CLEANED_PARTIONS_FILE


    #this file will be used to mount the partition after the formating
    local MOUNT_POINT_PARTITION_FILE=`mktemp`

    #we format device by device
    for d in $DEVICE_LIST
    do
        #we filter to get the current device
        local partition_of_current_disk=`mktemp`
        cat $CLEANED_PARTIONS_FILE |grep "^$d" >$partition_of_current_disk

        #we get the partitions available for a given device (must be in the same order
        #than the order in the partionning section file)
        local partition_list=`arch_formatting_get_partitions $d`
        
        n=1
        for p in $partition_list
        do
            #we get some parameters
            line=`common_get_line_n $partition_of_current_disk $n`
            mount_point=`echo $line |cut -d ' ' -f 4`
            fs=`echo $line |cut -d ' ' -f 3`
            n=$(( $n + 1 ))

            #we format 
            formatting_wrapper_$fs $p 

            #if it's swap, swapon, else we add it in the file created just before the loop
            if [ "$fs" = "swap" ]
            then
                swapon $p
                swapdev="$p"
            else
                echo "$mount_point:$p" >> $MOUNT_POINT_PARTITION_FILE
            fi
        done
    done

    #we mount the newly created partition and generate the fstab
    echo "#auto-generated by genautoo" >/etc/fstab
    for m in `sort $MOUNT_POINT_PARTITION_FILE`
    do
        dev=`echo $m|sed "s/.*://"`    
        mount_point=`echo $m|sed "s/:.*//"`
        mkdir -p $GLOBAL_INSTALL_DIR/$mount_point
        mount $dev $GLOBAL_INSTALL_DIR/$mount_point
        echo "$dev $mount_point auto defaults 0 1" >>/etc/fstab


    done

    echo "$swapdev none swap sw 0 0" >>/etc/fstab
}
